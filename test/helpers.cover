    1: import csv
    1: import os
    1: import unittest
    1: from pathlib import Path
       
       
   37: METRICS_HEADER = [
    1:     "run_id",
    1:     "timestamp",
    1:     "output_name",
    1:     "output_dir",
    1:     "exit_code_java",
    1:     "wall_seconds_java",
    1:     "user_seconds_java",
    1:     "sys_seconds_java",
    1:     "max_rss_kb_java",
    1:     "input_mapping_size_bytes",
    1:     "input_vcf_size_bytes",
    1:     "output_dir_size_bytes",
    1:     "output_triples",
    1:     "jar",
    1:     "mapping_file",
    1:     "output_path",
    1:     "combined_nq_size_bytes",
    1:     "gzip_size_bytes",
    1:     "brotli_size_bytes",
    1:     "hdt_size_bytes",
    1:     "exit_code_gzip",
    1:     "exit_code_brotli",
    1:     "exit_code_hdt",
    1:     "wall_seconds_gzip",
    1:     "user_seconds_gzip",
    1:     "sys_seconds_gzip",
    1:     "max_rss_kb_gzip",
    1:     "wall_seconds_brotli",
    1:     "user_seconds_brotli",
    1:     "sys_seconds_brotli",
    1:     "max_rss_kb_brotli",
    1:     "wall_seconds_hdt",
    1:     "user_seconds_hdt",
    1:     "sys_seconds_hdt",
    1:     "max_rss_kb_hdt",
    1:     "compression_methods",
       ]
       
       
    1: def make_executable(path: Path, content: str) -> None:
    7:     path.write_text(content)
    7:     path.chmod(path.stat().st_mode | 0o111)
       
       
    1: def seed_conversion_metrics_row(
           metrics_csv: Path, run_id: str, timestamp: str, output_name: str, output_dir: Path
       ) -> None:
    2:     metrics_csv.parent.mkdir(parents=True, exist_ok=True)
    4:     with metrics_csv.open("w", newline="") as f:
    2:         writer = csv.writer(f, lineterminator="\n")
    2:         writer.writerow(METRICS_HEADER)
    4:         writer.writerow(
    4:             [
    2:                 run_id,
    2:                 timestamp,
    2:                 output_name,
    2:                 str(output_dir),
    2:                 "0",
    2:                 "0.12",
    2:                 "0.10",
    2:                 "0.02",
    2:                 "10240",
    2:                 "100",
    2:                 "200",
    2:                 "300",
    2:                 "3",
    2:                 "fake.jar",
    2:                 "rules.ttl",
    2:                 str(output_dir),
                   ]
    2:             + [""] * 20
               )
       
       
    1: def env_with_path(bin_dir: Path) -> dict[str, str]:
    3:     env = os.environ.copy()
    3:     env["PATH"] = f"{bin_dir}:{env['PATH']}"
    3:     return env
       
       
    2: class VerboseTestCase(unittest.TestCase):
    1:     """Print explicit test start/end markers to make outcomes easy to scan."""
       
    1:     def run(self, result=None):
   10:         label = self.shortDescription() or self.id().split(".")[-1]
   10:         print(f"\n[TEST] {label}")
       
   10:         if result is None:
                   result = self.defaultTestResult()
       
   10:         failures_before = len(result.failures)
   10:         errors_before = len(result.errors)
   10:         skips_before = len(result.skipped)
   10:         unexpected_before = len(result.unexpectedSuccesses)
       
   10:         super().run(result)
       
   10:         failed = (len(result.failures) > failures_before) or (len(result.errors) > errors_before)
   10:         failed = failed or (len(result.unexpectedSuccesses) > unexpected_before)
   10:         skipped = len(result.skipped) > skips_before
       
   10:         if skipped:
                   print(f"[SKIP] {label}")
   10:         elif failed:
                   print(f"[FAIL] {label}")
               else:
   10:             print(f"[PASS] {label}")
       
   10:         return result
